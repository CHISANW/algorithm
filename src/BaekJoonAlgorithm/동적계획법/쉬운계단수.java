package BaekJoonAlgorithm.동적계획법;

import java.util.Scanner;

//https://www.acmicpc.net/problem/10844
/**
 * 문제를 풀기위한 점화식 -> n번째의 길이의 l만큼의 계단에서 계단의 수를 만들수있는 방법은 n-1의 번쨰의 경우의 수를 알고있을때 
 * l= 0일때는 -1칸의 계단은  할수없기 때문에  l+1일때만 가능
 *  dp[n][1] = dp[n-1][l+1];
 *
 * l >=1 && l<=8 일때에는 -1칸 ,+1칸을 해도 현재 n번의 계단의 포함되기때문에가능
 *  dp[n][1~8] = dp[n-1][l+1] + dp[n-1][l-1]
 *
 * l =0일때에는 n번째 길으이 계단을 +1하게되면 n+1칸의 계단의 수가 되기때문에 l-1칸만 계산해야한다.
 *  dp[n][9] = dp[n-1][l-1]
 *
 * ex)
 * n = 2일때 만들수 있는 경우의수는 10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98 = 총 17개의 가지가 가능하다.
 * n =1일때에는 모두 1개의 경우의 수를 가지기 때문에 dp[1][1] ~ dp[1][9] 까지의 각 l의 경우의수는 1가지이다. 그래서 n-1먼쨰의 수를 도출해 낼 수 있다.
 *
 * n = 2일때
 *
 * ==== dp[n-1][l+1] ==== 점화식
 * l = 0일때 dp[2][0] =  dp[1][1]  -> 1가지
 *
 * ==== dp[n-1][l+1] + dp[n-1][l-1] ==== 점화식
 * l = 1일때  dp[2][1] =  dp[1][0](0가지) + dp[1][2](1가지) -> 1가지
 * l = 2일때  dp[2][1] =  dp[1][1](1가지) + dp[1][3](1가지) -> 2가지
 * l = 3일때  dp[2][1] =  dp[1][2](1가지) + dp[1][4](1가지) -> 2가지
 * l = 4일때  dp[2][1] =  dp[1][3](1가지) + dp[1][5](1가지) -> 2가지
 * l = 5일때  dp[2][1] =  dp[1][4](1가지) + dp[1][6](1가지) -> 2가지
 * l = 6일때  dp[2][1] =  dp[1][5](1가지) + dp[1][7](1가지) -> 2가지
 * l = 7일때  dp[2][1] =  dp[1][6](1가지) + dp[1][8](1가지) -> 2가지
 * l = 8일때  dp[2][1] =  dp[1][7](1가지) + dp[1][9](1가지) -> 2가지
 *
 * ==== dp[n-1][l-1] ==== 점화식
 * l = 9일때  dp[2][9] =  dp[1][8](1가지) -> 1가지
 *
 * 총 1+1+2+2+2+2+2+2+2+1 가지수로 dp[2][9]는  17개의 계산수를 만들수있다.
 */
public class 쉬운계단수 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int MOD = 1000000000;

        int[][] dp = new int[n+1][10];

        for(int i = 1;i<=9;i++){
            dp[1][i] = 1;
        }

        for(int i = 2; i<=n;i++){
            for(int j = 0;j<=9;j++){
                switch (j){
                    case 0 ->
                        dp[i][j] = dp[i-1][j+1] % MOD;
                    case 9 ->
                        dp[i][j] = dp[i-1][j-1] % MOD;
                    default ->
                        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) %MOD;
                }
            }
        }

        int sum = 0;
        for(int i = 0;i<=9;i++){
            sum = (sum+ dp[n][i]) % MOD;
        }
        System.out.println(sum);
    }
}
